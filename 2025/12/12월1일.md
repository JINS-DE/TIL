# 코딩테스트 및 알고리즘
## SQL 
### 기본검색 및 정렬 (WHERE, ORDER BY)
```
SELECT [컬럼명들]
FROM [테이블명]
WHERE [조건들] (AND,OR 연산자 등)
ORDER BY [컬럼명들] (ASC, DESC)
```
### 그룹 제어
특정 컬럼들을 그룹화하여 조회
```
GROUP BY [컬럼명]
HAVING [GROUP BY절에 해당하는 조건]
```

예시
```SQL
SELECT CADDR. COUNT(CADDR)
FROM tCustomer as tcu
GROUP BY CADDR 
HAVING COUNT(CADDR)>2
```
### 분기문
CASE, WHEN, THEN, ELSE, END
```SQL
CASE [컬럼명]
WHEN [비교값1] THEN [반환값1]
WHEN [비교값2] THEN [반환값2]
WHEN [비교값3] THEN [반환값3]
ELSE 모든 조건 해당되지 않을 때 반환되는 값
END

[예시]
SELECT ENAME, DNUMBER, (CASE DNUMBER WHEN 'D1001' THEN '문구생산부'
                                     WHEN 'D2001' THEN '가구생산부'
                                     ELSE '부서 없음' END) AS '부서명'
FROM tEmployeee
```
```SQL
CASE
WHEN 조건1 THEN 조건1 충족할 때 반환되는 값
WHEN 조건2 THEN 조건3 충족할 때 반환되는 값
WHEN 조건2 THEN 조건3 충족할 때 반환되는 값
ELSE 모든 조건 해당되지 않을 때 반환되는 값
END

[예시]
SELECT ENAME, DNUMBER, (CASE WHEN DNUMBER = 'D1001' THEN '문구생산부'
                             WHEN DNUMBER = 'D2001' THEN '가구생산부'
                             ELSE '부서 없음' END) AS '부서명'
FROM tEmployeee
```

### 집합연산
UNION 사용 시 중복 요소는 추가 X, UNION ALL은 중복 요소까지 추가 O
```sql
SELECT [컬럼]
FROM [테이블]

UNION / UNION ALL 

SELECT [컬럼]
FROM [테이블]
```

### 순위집계
- RANK() : 1(100) -> 2(95), 2(95), 2(95) -> 5(80)
- DENSE_RANK() : 1(100) -> 2(95), 2(95), 2(95) -> 3(80)
- ROW_NUMBER() : 1(100) -> 2(95) -> 3(95) -> 4(95) -> 5(80)

```SQL
SELECT
RANK() OVER(PARTITION BY [그룹할 컬럼들] ORDER BY [순위 매길 컬럼])
FROM [테이블 명]
```
![alt text](image.png)

### JOIN
- INNER JOIN :  교집합
- LEFT OUTER JOIN : 차집합 (A-B)
- RIGHT OUTER JOIN : 차집합 (B-A)
- FULL OUTER JOIN : 합집합
- SELF JOIN : 자기자신과 SELF, 별칭을 통해 구분
- CROSS JOIN : 모든 경우의 수 1 -> 1,2,3 / 2-> 1,2,3 / 3-> 1,2,3


```SQL
SELECT *
FROM [테이블1] AS A
INNER JOIN [테이블2] AS B
ON A.KEY = B.KEY
```

### 집계 함수
- MAX([컬럼명])
- MIN([컬럼명])
- COUNT([컬럼명])
    - null 값은 제외
- SUM([컬럼명])
    - null 값은 제외
- AVG([컬럼명])
    - null 값은 제외

### 문자열 함수
- SUBSTRING('과수원의 사과는 맛있다',1,2) : "과수"
- LTRIM('    과수원의 사과는 맛있다') : '과수원의 사과는 맛있다'
- LTRIM('과수원의 사과는 맛있다','과') : '수원의 사과는 맛있다'
    - LTRIM은 왼쪽 RTRIM은 오른쪽
- LPAD('과수원의 사과는 맛있다',15,'$') : '$$$과수원의 사과는 맛있다'
    - 15만큼 공간에 STRING 채우고 나머지 공간은 '$' 패딩처리
    - RPAD도 마찬가지(오른쪽)
- REPLACE('과수원의 사과는 맛있다','과수원','비닐하우스') : '비닐하우스의 사과는 맛있다'
- LENGTH('과수원의 사과는 맛있다') : 12


## [백준 2230 수고르기](https://www.acmicpc.net/problem/2230)
### 풀이 방법
이분 탐색과 투 포인터 방식 2가지 방식으로 풀이를 할 수 있다. 둘 다 정렬 후 탐색해야 한다.
- 투포인터
    - 정렬된 배열에서 앞에서부터 전체 순회하면서 i와 비교할 index인 변수 pairIndex를 `arr[pairIndex]-arr[i] < M`이면 `pairIndex++` 해가며 늘려간다. 
        - 이미 정렬된 배열이기에 pairIndex가 이전보다 작아질 수 없다. 
        - `arr[pairIndex]-arr[i]`과 M을 비교해 M보다 크거나 같은 값 중에 가장 작은 값을 찾으면 된다.
    - 시간복잡도 : O(NlogN) = NlogN(정렬) + N(전체순회) + N(투포인터)

- 이분 탐색
    - 기준을 두고 그 기준 값과 차이가 M보다 크거나 같은 값을 이분탐색으로 찾는다. 
    - 시간복잡도 : O(NlogN) = NlogN(정렬) + N(전체순회) * logN(이분탐색)

- 참고
    - 자바에서 sort는 primitive type은 dual pivot quick sort 방식을 사용하고 객체를 참조하는 reference type은 Team Sort 방식(NlogN 보장, stable)을 사용한다. 혹시나 최악의 경우 O(N^2)이 나올까봐 `int[]`가 아니라 `Integer[]`를 사용했었는데 이번 문제는 상관이 없었다. 오히려 퀵소트 방식이 더빨랐다. 

### 코드
#### 투 포인터 (시간 360ms) -> 조금 더 효율적 
```java
import java.util.*;
import java.io.*;
public class Main{
    static int N,M;
    static Integer[] arr;
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        arr = new Integer[N];
        for (int i=0; i<N; i++){
            arr[i] = Integer.parseInt(br.readLine());
        }
        int pairIndex = 0;
        int ans = Integer.MAX_VALUE;
        Arrays.sort(arr);
        for (int i=0; i<N-1; i++){
            while (arr[pairIndex]-arr[i] < M && pairIndex < N-1){
                pairIndex++;
            }
            int diff = arr[pairIndex]-arr[i];
            if (diff>=M) ans = Math.min(ans, arr[pairIndex]-arr[i]);
        }
        System.out.println(ans);
    }
}
```

#### 이분 탐색 (시간 420ms)
```java
import java.util.*;
import java.io.*;
public class Main{
    static int N,M;
    static Integer[] arr;
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        arr = new Integer[N];
        for (int i=0; i<N; i++){
            arr[i] = Integer.parseInt(br.readLine());
        }
        int ans = Integer.MAX_VALUE;
        Arrays.sort(arr);
        for (int i=0; i<N-1; i++){
            ans = Math.min(ans, binarySearch(i));
        }
        System.out.println(ans);
    }

    static int binarySearch(int standard){
        int left = standard+1;
        int right = N-1;
        int mid, target;
        int diff = Integer.MAX_VALUE;
        while (left<=right){
            mid = left + (right-left)/2;
            target = arr[mid] - arr[standard];
            if (target < M){
                left = mid+1;
            } else {
                right = mid-1;
                diff = target;
            }

        }
        return diff;
    }
}
```
# [2025년 10월 15일] 회고 
## 📝 오늘의 한 줄 요약
DP 공부하기

## 📚 주제별 학습 내용 
### [486. Predict the Winner](https://leetcode.com/problems/predict-the-winner/description/)

#### Bottom-Up (테뷸레이션)
```PYTHON
class Solution:
    def predictTheWinner(self, nums: List[int]) -> bool:
        n=len(nums)
        dp=[[0]*n for _ in range(n)]

        # 길이가 1인 구간의 최대값은 자기 자신
        for i in range(n):
            dp[i][i]=nums[i]
        
        for length in range(2,n+1):
            for left in range(n+1-length):
                right = left+length-1
                left_pick = nums[left] - dp[left+1][right]
                right_pick = nums[right] - dp[left][right-1]
                dp[left][right] = max(left_pick,right_pick)
        
        return dp[0][n-1] >= 0
```

#### Top-Down (메모이제이션)
```python
class Solution:
    def predictTheWinner(self, nums: List[int]) -> bool:
        n = len(nums)
        
        # 1. '노트' 생성: 결과를 저장할 2D 리스트
        # 아직 계산되지 않았다는 것을 표시하기 위해 None으로 초기화합니다.
        memo = [[None] * n for _ in range(n)]

        def solve(i, j):
            # 2. '노트' 확인: 계산 전에 캐시부터 확인
            if memo[i][j] is not None:
                return memo[i][j]

            # 기저 사례: 남은 숫자가 하나일 때
            if i == j:
                return nums[i] # 이 경우는 바로 반환하므로 굳이 저장할 필요는 없음

            # 재귀 계산 로직 (기존과 동일)
            pick_left = nums[i] - solve(i + 1, j)
            pick_right = nums[j] - solve(i, j - 1)
            
            result = max(pick_left, pick_right)

            # 3. '노트'에 기록: 반환하기 전에 계산 결과를 저장
            memo[i][j] = result
            
            return result

        # 최종 결과 계산
        return solve(0, n - 1) >= 0
```
- `@lru_cache` 사용하면 자동 메모이제이션함

### [877.Stone Game](https://leetcode.com/problems/stone-game/)
- 얼핏 보면 위에 Predict the Winner와 똑같은 문제처럼 보인다. 
- 하지만 제한 조건을 잘 확인해보자 ! 
    - piles.length is even. -> piles 리스트의 개수는 짝수개이다.
    - sum(piles[i]) is odd. -> piles 리스트의 합은 홀수이다 = 무조건 승자가 있다. 
    
- Predict the Winner처럼 DP로 해결할 수 있는 문제지만 제한 조건을 잘 보면 굳이 dp까지 사용할 필요가 없다. 
    - 전체 리스트 크기가 짝수개
    - 총합이 홀수이므로 `sum[i%2==1들의 모임]`와 `sum[i%2==0들의 모임]`의 크기가 같을 수 없다.
    - 즉, Alice가 무조건 승리이다. 둘중 큰것만 계속 고르면됨. 

## ✨ 오늘 꼭 기억할 것
제약 조건에 "짝수", "홀수", "소수" 등의 특별한 단서를 잘 생각해보자. 

## ✍️ 오늘 돌아보기 끄적끄적
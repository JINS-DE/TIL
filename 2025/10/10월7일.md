# [2025년 10월 07일] 회고 
## 📝 오늘의 한 줄 요약
DFS/BFS, 위상정렬 등 그래프를 다시 보며 감을 잡자! 

## 📚 주제별 학습 내용 
### 다익스트라
시작점을 기준으로 모든 노드까지의 최단 경로를 알 수 있게하는 알고리즘
- 파이썬에서는 heapq(우선순위큐)를 사용하여 구현한다. 
    1. 초기화 : 출발 노드(0)를 제외한 모든 노드의 거리를 무한대로 설정
    2. 우선순위 큐 활용 : `(거리,노드)` 쌍을 우선순위 큐에 넣는다. 거리가 가장 짧은 노드가 항상 큐의 맨 앞에 오게 된다. 
    3. 반복 탐색 : 큐에서 가장 거리가 짧은 노드를 꺼낸다.
    4. 경로 갱신 : 해당 노드를 거쳐 다른 노드로 가는 경로가 기존 경로보다 더 짧다면, 거리를 갱신하고 우선순위 큐에 새로운 (갱신된 거리, 노드)를 추가한다. 
    5. 큐가 빌 때까지 반복! 

[백준 1753](https://www.acmicpc.net/problem/1753)

```python
import heapq  # 우선순위 큐(최소 힙) 라이브러리

def dijkstra(graph, start):
    # 1. 초기화
    # 모든 노드의 거리를 무한대로 초기화
    distances = {node: float('inf') for node in graph}
    # 시작 노드의 거리는 0으로 설정
    distances[start] = 0
    heap = [(0,start)]
    
    while heap:
        curr_distance, curr_node = heapq.heappop(heap)

        # 이미 처리된 노드 무시(더 짧은 경로가 이미 발견됨)
        if curr_distance > distances[curr_node]:
            continue
        
        for next_distance, next_node in graph[curr_node]:
            distance = curr_distance + next_distance
            # 거리 갱신 로직
            if distance < distances[next_node]:
                distances[next_node] = distance
                heapq.heappush(heap,(distance,next_node))

    return distances


# --- 예제 실행 ---
if __name__ == "__main__":
    # 그래프 정의 (인접 리스트)
    my_graph = {
        'A': [(8, 'B'), (1, 'C'), (2, 'D')],
        'B': [],
        'C': [(5, 'B'), (2, 'D')],
        'D': [(3, 'E'), (5, 'F')],
        'E': [],
        'F': [(1, 'A')]
    }

    # 'A' 노드에서 시작
    start_node = 'A'
    shortest_paths = dijkstra(my_graph, start_node)

    # 결과 출력
    print(f"'{start_node}'에서 출발하는 최단 경로:")
    for node, distance in shortest_paths.items():
        print(f"{node}까지의 거리: {distance}")
```
---
### 위상정렬
- 조건
    1. 간선이 방향성을 가진 그래프여야 한다. (a->b)
    2. 그래프 내부에 순환(Cycle)이 없어야 한다. (a->b->a : 사이클 발생(X))
- DAG(Direct Acyclic Graph) : 순환하지 않는 방향 그래프에서만 가능
- 큐, 스택 둘 다 할 수 있지만 큐로 구현이 편하다. 
- 시간복잡도 : O(V+E)
- 위상 정렬 프로세스
    1. 진입 차수가 0인 정점을 큐에 삽입한다. 
    2. 큐에서 원소를 꺼내 해당 원소에 연결된 간선을 제거한다. 
    3. 간선을 제거한 후 진입 차수가 0이 된 정점을 큐에 삽입한다. 
    4. 위 과정을 반복한다. 
- 위 프로세스 진행 중 모든 정점을 방문하기 전에 큐가 비게 된다면 사이클이 존재하는 것이다. 
- 큐에서 원소를 꺼낸 순서가 위상 정렬의 결과가 된다. 

```python
# 사이클 확인 로직
from collections import deque, defaultdict
def check_cycle_with_topological_sort(num_nodes: int, edges: List[List[int]]) -> bool:
    # 1. 그래프(인접 리스트)와 진입 차수(in-degree) 배열 초기화
    graph = defaultdict(list)
    in_degree = [0]*num_nodes
    for x,y in edges:
        graph[x].append(y)
        in_degree[y] += 1
    
    # 2. 진입 차수가 0인 노드들을 큐에 추가
    q=deque()
    for i in range(num_nodes):
        if in_degree[i]==0:
            q.append(i)
    
    processed_count  = 0
    # 3. BFS 기반 위상 정렬 실행
    while q:
        now_node = q.popleft()
        processed_count +=1

        # 현재 노드와 연결된 다른 노드들의 진입 차수를 1 감소
        for next_node in graph[now_node]:
            in_degree[next_node]-=1
            # 진입 차수가 0이 되면, 해당 노드도 큐에 추가 
            if in_degree[next_node]==0:
                q.append(next_node)

    # 4. 사이클 판별
    return  processed_count != num_nodes

# 예시 1: Course Schedule 1 (사이클 없음)
num_courses1 = 2
prerequisites1 = [[1, 0]]  # 1 -> 0
print(f"예시 1 (사이클 없음): {check_cycle_with_topological_sort(num_courses1, prerequisites1)}") # False

# 예시 2: Course Schedule 2 (사이클 있음)
num_courses2 = 2
prerequisites2 = [[1, 0], [0, 1]] # 1-> 0 -> 1
print(f"예시 2 (사이클 있음): {check_cycle_with_topological_sort(num_courses2, prerequisites2)}") # True
```

#### 위상 정렬 연상 신호탄!
- 핵심 키워드 : '순서'와 '의존성'
    - ~을 하기 전에 반드시 먼저 ~해야 한다. 
    - 선수과목이 있다 : 자료구조를 들으려면 프로그래밍 기초를 먼저 들어야 한다. 
    - 의존성 : A를 사용하기 위해 B 라이브러리가 있어야 한다. 
    - 순서대로 : 프로젝를 완료할 수 있는 전체 작업 순서를 출력하라
    - 규칙을 위반하지 않고
- "이 문제를 점(node)와 화살표로 표현할 수 있는가? 화살표의 방향(순서)를 따르거나 사이클을 찾는 것인가?"
---
### 재귀를 좀 더 쉽게 이해하기
재귀는 decision tree를 생각하면 조금 더 쉽다. node와 branch를 어떻게 구성할지만 정하면 이해하기 쉬움. 
- root : 시작점
- node : 선택을 해야 하는 지점 또는 특정 상태
- branch : 할 수 있는 선택지들
    - 코드에선 대부분 for문에 해당함. 
- leaf : 끝까지 파고 들어 선택된 경로가 끝나는 최종 결과

123을 순열로 표현한다 했을 때
_ _ _ : 각 자리에 대한 상태(비어있는지 채워졌는지)가 node, 각 자리에 1,2,3 중에 어떤 값을 넣을지 선택하는거는 branch

- DFS : 재귀 및 스택 사용
- BFS : deque 사용 

## ✨ 오늘 꼭 기억할 것
- 위상 정렬 로직 
    - 차수가 0인 애들 큐에 넣기! 
    - q에서 pop할 때마다 진입 차수 -1
    - 반복

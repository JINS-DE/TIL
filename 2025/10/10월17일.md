# [2025년 10월 17일] 회고 
## 📝 오늘의 한 줄 요약
ETL 서비스 Connection Reset Error 와이어샤크로 원인 분석하기 

## 📚 주제별 학습 내용 
### Connection Reset ERROR
CDN 서버 -> chunk 단위로 메모리 저장 -> GCS 업로드 형식. 
- Streaming 방식을 사용해서 바로바로 GCS에 업로드하는 방식
#### 문제의 발단
- wifi 5G를 사용했을 때는 잘 되었다, 근데 일반 2.4GHZ 쓰니 Connection Reset ERROR가 발생했다. 정확한 원인 분석을 위해 와이어샤크를 통해 패킷을 분석해보았다. 

#### Wireshark 분석
1. TCP 3-Way Handshake(SYN, SYN/ACK, ACK)가 정상적으로 이루어지며 연결 수립 완료 확인
2. CDN서버 HTTP GET 요청 완료
3. CDN서버에서 비디오 데이터를 보내기 시작
    - 이 때 속도가 엄청 빨랐음 
    - 최대 크기에 가까운 패킷 (MSS) `Len=1460` 으로 가득찬 TCP 세그먼트들을 계속 빠르게 보냄
    - CDN의 고성능 수신 트래픽이 클라이언트로 유입되고 있음을 의미한다.
    - 그만큼 gcs 업로드하는 송신 트래픽을 생성해야하는데, GCS 업롣 속도는 너무 느렸다.
4. TCP 수신 버퍼 고갈 및 `TCP ZeroWindow`
    - CDN서버에게 보내는 강제적인 '전송 중단' 명령
    - 원인 : 현재 로컬 커널 레벨에 존재하는 `TCP 수신 버퍼`가 가득 찼다. 
        - GCS 업로드 프로세스가 버퍼에서 데이터를 소비하는 속도 < CDN 다운로드 데이터가 버퍼에 쌓이는 속도
    - 동작 : TCP 스택은 데이터 유실을 막기 위해, 자신의 수신 가능 용량(Receive Window)가 0임을 알리는 `ZeroWindow` 패킷을 CDN서버에게 보낸다. 이 신호를 받으면 윈도우 크기가 다시 열렸다는 `Window Update` 패킷을 받기 전까지 데이터 전송을 완전히 중단해야 한다. 
    - `ZeroWindow` 패킷의 존재는 스트리밍 아키텍처의 병목 현상이 애플리케이션 레벨이 아닌, TCP 프로토콜 레벨에서 발생했음을 증명한다.

5. 불안정한 연결 및 연결의 붕괴 : 재전송(Retransmission)과 강제 종료(Reset)
    - 교착 상태 : 느린 GCS 업로드로 인해 버퍼를 신속히 비우지 못하고 Window Update를 보내지 못하고 있다. CDN 서버는 데이터를 보내지 못하고 무작정 대기하는 상태가 지속되었다. 
    - TCP 재전송 발생 : 이 불안정한 상태로 인해 패킷 유실 인식 오류로 이어지고, CDN 서버가 이미 보냈던 데이터를 다시보내는 `TCP Fast Retransmission` 등의 불필요한 트래픽 유발
    - 연결 리셋(Reset): TCP 프로토콜은 비정상적으로 오랫동안 ZeroWindow 상태가 지속되는 연결을 '죽은 연결(Dead Connection)'로 간주. 결국, CDN 서버의 TCP 스택은 자체 타임아웃(Timeout) 정책에 따라 이 비정상적인 연결을 정리하기 위해 RST (Reset) 패킷을 클라이언트에 전송.
    - 이 RST 패킷이 바로 우리 Python 애플리케이션에서 관측된 **ConnectionResetError**의 최종 원인


## [가장 많이 받은 선물](https://school.programmers.co.kr/learn/courses/30/lessons/258712?language=python3)

```python 
from itertools import combinations
from collections import defaultdict
def solution(friends, gifts):
    friends_idx_dict = {}
    for i,v in enumerate(friends):
        friends_idx_dict[v]=i
    
    giver_board = [[0]*len(friends) for _ in range(len(friends))]
    present_degree = defaultdict(int)
    
    for gift in gifts:
        a,b = gift.split()
        giver_board[friends_idx_dict[a]][friends_idx_dict[b]]+=1
        present_degree[friends_idx_dict[a]]+=1
        present_degree[friends_idx_dict[b]]-=1

    answer = defaultdict(int)
    for a, b in combinations(friends,2):
        a = friends_idx_dict[a]
        b = friends_idx_dict[b]
        if giver_board[a][b] > giver_board[b][a]:
            answer[a]+=1
        elif giver_board[a][b] < giver_board[b][a]:
            answer[b]+=1
        else:    
            if present_degree[a] > present_degree[b]:
                answer[a]+=1
            elif present_degree[a] < present_degree[b]:
                answer[b]+=1
    maximum = 0
    for val in answer.values():
        maximum=max(val,maximum)
    return maximum
```

## [도넛과 막대 그래프](https://school.programmers.co.kr/learn/courses/30/lessons/258711)
### bfs 정석
```python
from collections import defaultdict,deque
def solution(edges):
    # 1. 그래프 정보 초기화
    max_node = 0
    adj = defaultdict(list)
    indegree = defaultdict(int)
    outdegree = defaultdict(int)
    
    for a,b in edges:
        adj[a].append(b)
        indegree[b]+=1
        outdegree[a]+=1
        max_node = max(max_node,a,b)
        
    # 2. 시작 정점 찾기
    start_node = -1
    for i in range(1, max_node + 1):
        if indegree[i] == 0 and outdegree[i] >= 2:
            start_node = i
            break
    
    answer=[start_node,0,0,0] # [초기 시작 정점, 도넛, 막대, 8자]
    visited = [0] * (max_node + 1)
    
    for node in adj[start_node]:
        if visited[node]:
            continue
        # BFS로 한 덩어리의 노드와 간선 수 세기
        q = deque([node])
        visited[node] = True
        node_count = 1
        edge_count = outdegree[node]
        
        while q:
            curr = q.popleft()
            for neighbor in adj[curr]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    q.append(neighbor)
                    node_count += 1
                    edge_count += outdegree[neighbor]
        
        if edge_count == node_count -1: # 막대 그래프
            answer[2] += 1
        elif edge_count == node_count + 1: # 8자 그래프
            answer[3] += 1
        else:
            answer[1]+=1
        
    return answer
```
### 진입차수 진출차수 만으로 해결하기
```python
from collections import defaultdict

def solution(edges):
    # 1. 그래프 정보 수집
    in_degree = defaultdict(int)
    out_degree = defaultdict(int)
    nodes = set()
    for a,b in edges:
        in_degree[b] += 1
        out_degree[a] += 1
        nodes.add(a)
        nodes.add(b)
    
    # 2. 시작점, 8자와 막대모양 찾기
    answer = [0,0,0,0] # [시작점, 도넛, 막대, 8자 ]
    for node in nodes:
        if in_degree[node]==0 and out_degree[node]>=2: # 시작점
            answer[0]=node
        elif in_degree[node]>=2 and out_degree[node]==2: # 8자
            answer[3]+=1
        elif out_degree[node]==0: #막대
            answer[2]+=1
    
    total = out_degree[answer[0]]
    answer[1] = total - answer[2] - answer[3]
    return answer
```

## [산 모양 타일링](https://school.programmers.co.kr/learn/courses/30/lessons/258705)
```python 
"""
사다리꼴 안의 삼각형의 개수 = 2n+1 개
윗변의 길이 n, 아랫변의 길이 n+1
"""
def solution(n, tops):
    mod = 10007
    dp=[[0,0] for _ in range(n)]
    
    dp[0][0] = 2 if tops[0]==0 else 3
    dp[0][1] = 1
    
    for i in range(1,n):
        if tops[i]:
            dp[i][0] = dp[i-1][0]*3 + dp[i-1][1] * 2   
        else:
            dp[i][0] = dp[i-1][0]*2 + dp[i-1][1]    
            
        dp[i][1] = dp[i-1][0] + dp[i-1][1]
        
        dp[i][0]%=mod
        dp[i][1]%=mod
    
    answer = dp[n-1][0] + dp[n-1][1]
    answer%=mod
    return answer
```


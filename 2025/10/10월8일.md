# [2025년 10월 08일] 회고 
## 📝 오늘의 한 줄 요약
슬라이딩 윈도우 방식 (투포인터), 누적합(Prefix Sum), DP

## 📚 주제별 학습 내용 
- 코드는 [깃허브](https://github.com/JINS-DE/LeetCode) 참고 
### [Merge Intervals](https://leetcode.com/problems/merge-intervals/description/)
```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
```
#### 초기화
- intervals 요소의 앞자리로 정렬
- prev = [1,3] 설정

#### 풀이
- prev[1] 보다 curr[0] 크거나 같은 경우 합친다. [1,3] + [2,6] -> [1,6]
- 아닌 경우 prev를 정답에 추가 후 prev 갱신

### [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)
```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3. Note that "bca" and "cab" are also correct answers.
```
- 슬라이딩 윈도우 방식(left,right)
- 중복체크 할 수 있는 set()를 만든다. 
- 중복 발생 시 set remove 후 left+1
- 중복 없을 시 set add후 right+1, 정답 갱신


### [Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)
```
부분배열로 k를 만들 수 있는 총 경우의 수 
Example 1:
Input: nums = [1,1,1], k = 2
Output: 2

Example 2:
Input: nums = [1,2,3], k = 3
Output: 2
```
- prefix sum 심화 문제 
- prefix sum 공식 : sum(i,j) = prefix_sum(j)-prefix_sum(i-1)
    - sum(i,j)가 k가 되는 것을 골라야 한다. 
    - prefix_sum(i-1) = prefix_sum(j) - k 이 식을 활용해서 hash 사용해서 풀면됨

### [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
```
target의 제일 왼쪽, 제일 오른쪽 구하기

Example 1:
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```
- 이분 탐색을 두 번 돌린다.
    - 한 번은 맨 왼쪽(start) 찾기 `mid==target`시 start=mid, right=mid-1
    - 한 번은 맨 오른쪽(end) 찾기 `mid==target`시 end=mid, left=mid+1

### [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)
```
k번째 요소 찾기

Example 1:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
```
- 정렬 쓰고 k번째 쓰면 풀린다. 근데 정렬쓰지 말고 풀어보라고 문제에 적혀있음.
- heap 자료구조를 사용했다.
    - k의 크기만큼 min heap을 관리하고 k의 크기가 넘어가면 하나씩 빼준다. 
    - 전체 루프를 다 돌고 heap pop이 정답 

### [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)
```
target 이상인 부분배열 중 가장 짧은 크기 찾기

Example 1:
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
```
- 처음에는 target 이상인 줄 모르고 target에 맞춰야 하는 줄 알고 prefix sum을 사용해서 풀었는데 틀렸다. target 이상이니까 슬라이딩 윈도우를 사용하는게 가장 효율적이었다. 
- 정확한 값의 부분배열을 찾을 때는 prefix_sum, 정해진 값 이상을 구할 때는 슬라이딩 윈도우 방식을 구현해야 하는 것을 배웠다. 

### [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)
```
주식 최대 이득 내기

Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```
- min_price 갱신, max_profit 갱신 하면 됨

### [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/)
```
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```
- 점화식 dp[i] = dp[i-1] + dp[i-2]

### [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/description/)
```
최장 부분 수열 구하기

Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```
- 전형적인 dp 문제 
    - dp[i] : i번째 포함, 만들 수 있는 가장 긴 부분 수열의 길이
    - 점화식 : `nums[j]<nums[i]` 일 때 dp[i] = max(dp[i],dp[j]+1)
        - i(j보다 뒤에 인덱스)가 더 크면 j의 부분수열에 포함될 수 있기 때문
- 근데 문제에서 O(n lon n)으로 최적화 해보라는데 이건 내일해볼 예정


# [2025년 11월 05일] 회고
## 📝 오늘의 한 줄 요약
애자일 M (IVI) 방식, DDD(Why DDD?, 핵심구성요소 Entity, VO)

## 📚 주제별 학습 내용 
# 현대의 일하는 방식 : 애자일
기업의 "생존"과 "지속성장" 중점
## 애자일
### M (IVI)
M은 Interactive(상호적인), Value-Oriented, Iterative(반복적인) 첫자인 I+V+I 를 합성한 알파벳이다.

#### Value-Oriented
- 우리가 만드는 제품/서비스의 가치(철학)가 제일 중요하고 그 가치를 제공하기 위한 방법이나 결과물은 상황변화에 따라 유연하게 바꿔 나가야 한다는 사상
- 가치 : 제품이나 서비스를 만드는 이유 
- **왜 이 일을 하는지 그 비전을 고수하면서 방법과 결과물은 과감히 바꾸거나 버릴 수 있어야 한다.**
    - 가치를 주지 못하는 것은 바꾸거나 버린다.

#### Interactive
- 제품과 서비스를 중심으로 관련된 사람들이 지속적인 쌍방향 소통을 해야 한다. 
- Biz(사업)-DevOps 간 쌍방향 소통과 협업

#### Iterative
- 최소한의 기능으로 시작하여 끊임없는 **실험과 학습**의 반복하면서 점차 그 완성도를 높여가는 사상
- 린스타트업, 스크럼, 칸반 방법론 등
    - 린스타트업 : mvp 만들어서 결과 측정, 학습해서 더 나은 제품으로 만들어감(Build->Messure->Learn 순환)
    - 스크럼 : 1~4주 단위로 제품/서비스를 개발
    - 칸반 : 백로그(할일)를 나누어 반복적으로 개발
---
# DDD
## Why? DDD? 
### DDD(Domain-Driven Design)이란??
DDD는 소프트웨어의 중심을 '도메인(Domain)'에 두는 설계 사상이다.
- 도메인 : 비즈니스가 이루어지는 특정 영역(ex:'은행', '온라인 쇼핑')을 의미
- 비즈니스 로직과 규칙이 핵심이 되도록 모델링하는 것
    - 데이터베이스, 프레임워크가 중심이 아니다.
- 보편 언어(Ubiquitous Language)를 통해 긴밀하게 소통하며 도메인 모델을 구축한다. 
    - 개발자와 도메인 전문가와 소통에 통일성이 있어야 함. 

### ❓ DDD는 왜 필요한가?
소프트웨어 프로젝트가 실패하는 가장 큰 이유 중 하나는 "만들긴 했는데, 정작 비즈니스 문제를 해결하지 못해서"이다. 
- 개발팀이 이해한 비즈니스와 실제 비즈니스 간의 괴리가 발생하기 때문 !
- **이 간극을 메우는 것이 핵심 목표이다**
- 복잡성 관리: 단순한 CRUD가 아닌, 복잡한 비즈니스 규칙과 프로세스를 다뤄야 할 때 DDD는 빛을 발한다.
- 커뮤니케이션 향상: 개발자와 현업 전문가와 보편 언어(동일한 언어)를 사용함으로, 요구사항의 오해를 줄이고 본질에 집중할 수 있다.
- 유지보수성 및 확장성 : 비즈니스 로직이 도메인 모델 내에 캡슐화되어 있어서, 시스템이 변경되거나 확장될 대 영향을 최소화하고 수정이 용이하다. 


| 특징 | 전통적 개발 (Data-Driven) | 도메인 주도 설계 (DDD) |
| :--- | :--- | :--- |
| **중심** | 데이터베이스 / 스키마 | **비즈니스 로직 / 도메인 모델** |
| **주요 관심사** | "어떻게 저장할 것인가?" (How) | **"무엇을 하는가? 규칙은 무엇인가?" (What & Why)** |
| **비즈니스 로직 위치** | 서비스 계층, 트랜잭션 스크립트 (흩어짐) | **도메인 모델 (객체) 내에 캡슐화** |
| **소통 언어** | 개발 용어 (Table, Column, DTO) | **보편 언어 (Ubiquitous Language)** |
| **결과물** | 빈약한 도메인 모델 (Anemic Domain Model) | **풍부한 도메인 모델 (Rich Domain Model)** |
| **적합성** | 간단한 CRUD 애플리케이션 | **복잡한 비즈니스 로직을 가진 시스템** |
---


### 실제비즈니스 사례와 연결
#### 전통적 방식(데이터 중심)
- OrderService가 모든 일을 처리
```java
// 모든 로직이 서비스 레이어에 노출됨
public class OrderService {
    
    private OrderRepository orderRepository;
    private ProductRepository productRepository;
    private CouponService couponService;

    // '트랜잭션 스크립트' 패턴
    public void createOrder(Long userId, Long productId, int quantity, Long couponId) {
        
        // 1. 상품 재고 확인
        Product product = productRepository.findById(productId);
        if (product.getStock() < quantity) {
            throw new StockException("재고 부족");
        }
        
        // 2. 쿠폰 유효성 검사 및 할인 계산
        double discount = couponService.calculateDiscount(couponId, product.getPrice() * quantity);
        
        // 3. 총 금액 계산
        double finalPrice = (product.getPrice() * quantity) - discount;
        
        // 4. 주문 생성 (DTO 또는 빈약한 엔티티)
        Order order = new Order();
        order.setUserId(userId);
        order.setProductId(productId);
        order.setTotalPrice(finalPrice);
        //...
        
        // 5. DB 저장
        orderRepository.save(order);
        
        // 6. 재고 차감 (잊어버리기 쉬움)
        product.decreaseStock(quantity);
        productRepository.save(product);
    }
}
```
- 문제점 : `Order` 객체는 데이터만 담는 껍데기임
- 주문과 관련된 모든 비즈니스 규칙이 OderService에 흩어져 있음
- 다른 곳에서 주문을 생성해야 한다면 이 로직을 복사/붙여넣기 하거나 중복 구현해야함

#### 도메인 중심 ddd 방식
`Order` 객체가 스스로의 상태와 규칙을 책임진다. 

```java
// 'Order'가 'Aggregate Root' 역할을 수행
public class Order {

    private Long id;
    private List<OrderLine> orderLines;
    private Money totalPrice; // '돈'을 표현하는 Value Object
    private OrderStatus status;
    private Coupon coupon;

    // 팩토리 메서드 또는 생성자를 통해 '올바른' 주문만 생성
    public static Order create(User user, Product product, int quantity, Coupon coupon) {
        
        // 1. 비즈니스 규칙 (Invariant) 검증
        product.checkStock(quantity); // 상품 스스로 재고를 확인
        
        // 2. 주문 라인 생성
        OrderLine line = new OrderLine(product, quantity);
        
        // 3. 총 금액 계산 (쿠폰 적용)
        Money finalPrice = line.getPrice();
        if (coupon != null) {
            finalPrice = coupon.applyDiscount(finalPrice);
        }

        Order order = new Order(user, List.of(line), finalPrice);
        
        // 4. 도메인 이벤트 발행 (옵션)
        // order.publishEvent(new OrderCreatedEvent(order.id));
        
        return order;
    }
    
    // ... 생성자, 다른 메서드들 ...

    // 주문 취소 로직 (스스로의 상태를 변경)
    public void cancel() {
        if (this.status == OrderStatus.SHIPPED) {
            throw new IllegalStateException("배송 중인 상품은 취소할 수 없습니다.");
        }
        this.status = OrderStatus.CANCELLED;
        // + 재고 복구 이벤트 발행 등
    }
}

// 애플리케이션 서비스는 '조율'만 담당
public class OrderApplicationService {
    
    private OrderRepository orderRepository;
    private ProductRepository productRepository;
    private CouponRepository couponRepository;

    // 트랜잭션을 관리
    @Transactional
    public Long placeOrder(Long userId, Long productId, int quantity, Long couponId) {
        
        // 1. 필요한 도메인 객체들을 '조회'
        User user = ...;
        Product product = productRepository.findById(productId);
        Coupon coupon = couponRepository.findById(couponId);
        
        // 2. 도메인 객체에게 '위임'
        Order order = Order.create(user, product, quantity, coupon);
        
        // 3. 결과를 '저장'
        orderRepository.save(order);
        
        return order.getId();
    }
}
```
## 핵심 구성요소(Building Blocks)
### 1. Entity (엔티티)
- 정의: 고유한 식별자(id)를 가지며, 시간이 지남에 따라 상태가 변하더라도 그 식별자로 구별되는 도메인 객체이다. 
- 목적: 비즈니스 프로세스에서 "누가" 또는 "무엇이"에 해당하며, 생성, 수정, 삭제의 "생명주기(Life Cycle)"을 갖는 대상을 표현하기 위해 필요합니다. 
- 특징:
    - 식별성 : `id` 필드를 가진다.
    - 가변성 : 상태가 변할 수 있다. (예를 들어, '주문'의 상태가 '결제완료'에서 '배송중'으로 바뀜)
    - 연속성 : 생성 시점부터 삭제될 때까지 추적 가능
    - 스스로의 상태 관리 : `setOrderStatus()` 같은 단순한 세터가 아니라, `ship()` 배송, `cancel()` 취소처럼 비즈니스 의미를 담은 메서드를 통해 스스로 상태를 변경한다. 
- 코드예시 : 주문 번호(`id`)로 식별, 상태(`status`)가 계속 변함

```java
// Order는 Aggregate Root이기도 한 Entity입니다.
public class Order {

    private Long id; // 식별자
    private OrderStatus status; // 상태 (가변)
    private List<OrderLine> orderLines;
    private Money totalPrice; // 값 객체(VO) 사용

    // ... 생성자 ...

    // 비즈니스 로직을 포함한 메서드 (스스로 상태를 관리)
    public void ship() {
        if (this.status != OrderStatus.PAYMENT_COMPLETED) {
            throw new IllegalStateException("결제 완료 상태에서만 배송할 수 있습니다.");
        }
        this.status = OrderStatus.SHIPPED;
        // + (선택) 배송 시작 이벤트 발행
        // DomainEventPublisher.publish(new OrderShippedEvent(this.id));
    }

    public void cancel() {
        if (this.status == OrderStatus.SHIPPED) {
            throw new IllegalStateException("배송 중인 주문은 취소할 수 없습니다.");
        }
        this.status = OrderStatus.CANCELLED;
        // + 재고 복구 로직 등
    }

    // ID를 이용한 동등성 비교 (매우 중요)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Order order = (Order) o;
        // id가 null이 아니고, 고유성이 보장된다면 id로만 비교
        return id != null && id.equals(order.id);
    }

    @Override
    public int hashCode() {
        // id가 있다면 id의 hashCode를 반환
        return id != null ? id.hashCode() : System.identityHashCode(this);
    }
}
```
- 실무 적용: '고객(Customer)', '상품(Product)', '게시글(Post)', '회원(User)' 등. DB 테이블과 1:1로 매핑되는 경우가 많지만, DB 테이블 자체가 엔티티는 아니다. 비즈니스 식별성이 핵심이다.

### 2. Value Object (VO, 값 객체)
- 정의 : 식별자 없이 속성(attributes) 그 자체로 자신을 표현하며, **불변(Immutable)** 객체이다.
- 목적 : 도메인의 특정 '값'이나 '개념'을 명확하게 표현하고, 불변성을 통해 시스템의 안정성과 예측 가능성을 높이기 위해 필요하다. 
- 특징:
    - 비식별성 : `id`가 없음
    - 불변성(Immutable): 한번 생성되면 절대 상태가 변하지 않음
    - 속석 기방 동등성: 모든 속성(필드)의 값이 같으면 같은 객체로 간주한다. (`equals()`와 `hashCode()`를 반드시 오버라이드 해야한다.)
    - 교체 (Replacement): 값이 바뀌어야 한다면, 기존 객체를 수정하는 대신 새로운 값 객체를 생성하여 통째로 교체한다. 

- 코드예시: 돈(Money)가 대표적인 값 객체이다. 10,000원이라는 값 자체는 식별자가 없으며, 10,000원은 항상 10,000원이다. 
    - 실무 팁: Java 16 이상의 record 타입을 사용하면 불변성과 equals(), hashCode(), toString()을 자동으로 구현해 주어 값 객체를 만들기에 완벽하다.

```java
// Java record를 사용한 완벽한 Value Object
public record Money(long amount, String currency) {

    // 불변성 보장을 위한 방어적 복사 (필요 시)
    // (이 예제에서는 amount, currency가 불변이라 필요 없음)

    // 값 객체는 스스로의 로직을 가질 수 있음 (행위를 포함)
    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }
        // '수정'하는 것이 아니라 '새로운' Money 객체를 반환 (불변성)
        return new Money(this.amount + other.amount, this.currency);
    }

    public Money multiply(int multiplier) {
        return new Money(this.amount * multiplier, this.currency);
    }

    // (record가 자동으로 equals()와 hashCode()를 구현해 줌)
    // equals() : return this.amount == other.amount && this.currency.equals(other.currency);
}

// 만약 record를 쓰지 않는다면 (Java 16 미만)
public final class Money { // 1. 상속 불가 (final)
    private final long amount;    // 2. 필드는 final
    private final String currency;

    public Money(long amount, String currency) {
        this.amount = amount;
        this.currency = currency;
        // 3. 생성자에서만 값 할당
    }

    // 4. Setter 없음. Getter만 있음
    public long getAmount() { return amount; }
    public String getCurrency() { return currency; }

    public Money add(Money other) { ... } // 로직은 동일

    // 5. 속성 기반 동등성 비교 (필수)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Money money = (Money) o;
        return amount == money.amount && Objects.equals(currency, money.currency);
    }

    // 6. 동등성 비교에 사용된 필드로 hashCode 생성 (필수)
    @Override
    public int hashCode() {
        return Objects.hash(amount, currency);
    }
}
```
- 실무 적용:
    - `int price` (X) -> `Money price` (O)
    - `String street`, `String city`, `String zipCode` (X) -> `Address address` (O)
    - `LocalDateTime startTime`, `LocalDateTime endTime` (X) -> `Period duration` (O)
- 흔한 실수:
    - Primitive Obsession(기본형 집착): `int price`처럼 기본형 변수를 쓰는 것. `price`가 음수가 될 수 있거나, 통화 단위를 고려해야 하는 로직이 누락되기 쉽다. `Money` VO를 쓰면 생성자에서 `if(amount<0)` 검증을 넣을 수 있다.
    - VO에 Setter를 추가하는 실수는 불변성이 깨지는 최악의 실수
    - `equals()` / `hashCode()` 미구현


| 기준 | Entity (엔티티) | Value Object (값 객체) |
| :--- | :--- | :--- |
| **식별 기준** | **식별자 (ID)** | **속성 값 (Attributes)** |
| **핵심** | **"누구인가?" (Who / Which)** | **"무엇인가?" (What)** |
| **생명 주기** | **O (생성, 수정, 삭제)** | **X (불변, 필요시 교체)** |
| **가변성** | **Mutable (가변)** | **Immutable (불변)** |
| **equals() 비교** | **ID가 같으면 true** | **모든 속성 값이 같으면 true** |
| **예시** | **Order (주문), User (회원)** | **Money (돈), Address (주소)** |

❗핵심은 엔티티는 **존재**로 식별되고, 값 객체는 **값**으로 식별된다. 
